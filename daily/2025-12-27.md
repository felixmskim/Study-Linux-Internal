# 📅 2025-12-27

## 🎯 목표
- ```struct task_struct``` 파일에서 우선순위 관련 필드 ( ```prio```, ```static_prio```, ```normal_prio```, ```rt_prio```)을 분석한다.

## 📝 학습 내용
- **우선순위의 다변화 필요성:** 리눅스는 일반 프로세스(CFS)와 실시간 프로세스(RT)를 동시에 관리해야 한다. 이를 위해 하나의 숫자가 아닌 여러 단계의 우선순위 개념을 사용한다.
- **Priority Inversion 방지:** 낮은 우선순위의 프로세스가 높은 우선 순위 프로세스의 자원을 점유할 때 발생하는 문제를 해결하기 위해 동적 우선순위(prio)가 필요함을 학습했다.

## 🔍 소스코드 분석: `task_struct`
- **파일 위치:** `include/linux/sched.h` (Line 865~868)
- **핵심 코드:**
  ```c
  int				prio;                 // (1) 실제 스케줄러가 판단하는 '최종' 우선순위
  int				static_prio;          // (2) 사용자가 설정한 값 (Nice 값 기반)
  int				normal_prio;          // (3) 스케줄링 정책(Policy)에 따라 계산된 값
  unsigned int			rt_priority;  // (4) 실시간 프로세스를 위한 전용 순위
  ```

### 1. 필드별 상세 역할 및 관계
  - ```static_prio``` : 프로세스 생성 시 부여받는 고정 값. Nice 값 (-20 ~ 19)을 커널 내부 값(100 ~ 139)으로 매핑된다.
  - ```normal_prio``` : 정적 우선순위와 스케줄링 정책을 조합한 값. RT프로세스라면 rt_priority를 반영하여 개선된다.
  - ```prio``` : Effective Priority. 현재 시점에서 스케줄러가 사용하는 값. Priority Inheritance 등에 의해 일시적으로 상승할 수 있다.
  - ```rt_priority``` : RT 스케줄러 전용값. 0이면 일반 프로세스, 1~99이면 실시간 프로세스.

  왜 이렇게 복잡하게 나눴을까? 만약 prio 하나만 있다면, 우선순위 상속(PI)이 일어난 후 원래의 우선순위로 되돌아갈 방법이 없기 때문이디. 그래서 원래의 의도(static_prio)와 현재의 상태(prio)를 분리해서 관리한다.

## 🔍 직면한 문제 & 해결 (Troubleshooting)
- **문제:** Remote-WSL 환경에서 리눅스 커널 분석을 하려고 하니 노트북 팬이 너무 세게 돌아갔다. 노트북 온도가 너무 높으면 스스로 성능을 낮추는 **Throttling** 기능이 있다. 고장 날 확률이 낮지만 높은 온도가 지속되면 배터리 효율이나 팬의 수명에 장기적으로 영향을 줄 수 있다. 그리고 CPU 점유율이 높으면 다른 작업(e.g. 웹 검색)이 느려지거나 버벅거림을 느낄 수 있다.

- **원인:**
  1. **VS Code Server의 인덱싱 작업** : Remote-WSL을 사용하면 WSL 내부에 VS Code Server 설치한다. 특히 리눅스 커널처럼 파일이 수만 개인 프로젝트를 열면, IntelliSense(코드 자동 완성, 정의 이동 등) 기능을 제공하기 위해 모든 파일을 스캔하고 인덱싱한다. 이때 CPU 사용량이 급증한다.
  2. **WSL2의 가상화 구조** : WSL2는 실제 리눅스 커널을 가상화(Hyper-V) 위에서 실행한다. 이 과정에서 vmmem이라는 프로세스가 메모리와 CPU를 점유하는데, 윈도우와 자원을 주고받는 과정에서 오버헤드가 발생하여 하드웨어에 부담을 준다.
  3. **Extension(확장 프로그램)의 부하** : C/C++ 확장 프로그램이나 git-graph 같은 도구들이 WSL 내부에서 실시간으로 파일 변경을 감시하고 분석하기 때문에 리소스를 지속적으로 소모한다.

- **해결:** WSL 자원을 제한한다. 윈도우 사용자 폴더 ```(C:\Users\사용자이름)```에 ```.wslconfig``` 파일을 만들어 WSL이 사용할 수 있는 최대 메모리와 CPU 코어 수를 제한할 수 있다.
  
  **1.설정 내용 준비 및 파일 생성**
  먼저, 원하는 설정값을 변수에 담아 파일을 생성한다. (아래 예시는 메모리 4GB, CPU 코어 2개로 제한하는 설정)

  ```PowerShell
  # 1. 설정할 내용을 변수에 저장합니다.
  $configContent = @"
  [wsl2]
  memory=4GB
  processors=2
  "@

  # 2. $HOME 위치에 .wslconfig 파일을 생성하고 내용을 씁니다.
  $configContent | Out-File -FilePath "$HOME\.wslconfig" -Encoding utf8
  ```

  **2.파일이 제대로 만들어졌는지 확인**
  파일이 정확한 위치에 생성되었고 내용이 잘 들어갔는지 확인한다.

  ```PowerShell
  # 파일 내용 출력
  Get-Content "$HOME\.wslconfig"
  ```

  **3.WSL2 재시작**
  설정 파일은 WSL이 완전히 종료되었다가 다시 켜질 때 적용된다. 실행 중인 모든 WSL 인스턴스를 강제로 종료하자.
  ```PowerShell
  # 모든 WSL 가상 머신 종료
  wsl --shutdown
  ```

  **추가로, 파일 수정하고 싶을 때**
  ```PowerShell
  # 수정 후 다시 한번 wsl --shutdown 입력
  notepad "$HOME\.wslconfig"
  ```

## 💡 인사이트 (오늘 깨달은 것)
- `prio` 필드가 단순히 숫자가 아니라 `static_prio`, `normal_prio` 등으로 세분화되어 있다.
- 이는 실시간(RT) 프로세스와 일반 프로세스를 동시에 처리하기 위한 설계임을 깨달음.
- **설계의 유연성:** prio 필드가 여러 개인 이유는 Priority Inheritance와 같은 동적인 상황에 대응하면서도, 프로세스의 원래 본분을 잊지 않기 위함이다.
- **성능과 확장성:** Many-core 환경에서 각 태스크의 우선순위를 빠르게 계산하고 비교하는 로직이 스케줄러의 Scalability와 직결됨을 깨달았다.

## 🔗 참고 자료
- 리눅스의 태스크 모델, 'task_struct' 자료구조
- [Link] https://velog.io/@jinh2352/Linux-5-%EB%A6%AC%EB%88%85%EC%8A%A4%EC%9D%98-%ED%83%9C%EC%8A%A4%ED%81%AC-%EB%AA%A8%EB%8D%B8