# 📅 2025-12-28

## 🎯 목표
- prio 필드들이 실제로 어떻게 바뀌는지 확인한다. ```kernel/sched/syscalls.c``` 파일에 있는 `effective_prio()` 함수를 분석해 보자. 이 함수가 바로 우선순위 관련 필드를 조합해서 최종 prio를 리턴해주는 핵심 로직이다.

## 📝 학습 내용
- 리눅스 커널 6.6 버전 전후로 스케줄러 코드가 너무 거대해지자, 커널 개발자들이 ```kernel/sched/core.c```에 있던 시스템 콜 관련 로직(nice, sched_setscheduler 등)을 ```kernel/sched/syscalls.c```라는 별도의 파일로 분리했다.
- ```effective_prio()```는 주로 nice 값을 설정하거나 스케줄링 정책을 바꿀 때 호출되기 때문에, 시스템 로직과 함께 이동되었다. (전에는 ```kernel/sched/core.c```에 있었다)
  ```bash
  # 이렇게 함수 위치 찾아냄
  grep -n "static int effective_prio" kernel/sched/*.c
  ```

- 단순히 prio = normal_prio라고 하면 될 것 같은데, 왜 굳이 이 함수를 거칠까? 그 이유는 Priority Inheritance 때문이다.

  - **상황:** 낮은 우선순위의 태스크가 높은 우선순위 태스크가 필요한 뮤텍스(lock)를 쥐고 있을 때, 커널은 일시적으로 낮은 태스크의 우선순위를 높여준다(Boosting).

  - **문제:** 이때 그냥 normal_prio를 써버리면 부스팅된 효과가 사라지고 다시 원래의 낮은 우선순위로 돌아간다.

  - **해결:** effective_prio()는 "현재 이 녀석이 RT급으로 부스팅되어 있는가?"를 체크해서, 그렇다면 그 부스팅된 값을 보호해 주는 역할을 한다.

## 🔍 소스코드 분석1: `effective_prio()`
- **파일 위치:** `kernel/sched/syscalls.c` (Line 52~63)
- 프로세스의 **실제 유효 우선순위**를 최종 확정하는 역할을 한다. 만약 프로세스가 이미 RT 영역(0~99)에 있다면, 굳이 ```normal_prio```로 덮어쓰지 않고 현재의 높은 우선순위(```prio```)를 그대로 지켜준다는 뜻이다.
- **핵심 코드:**
  ```c
  static int effective_prio(struct task_struct *p)
  {
    // 현재 프로세스의 상태를 기반으로 normal priority를 계산해 저장한다.
    p->normal_prio = normal_prio(p);
    /*
    * If we are RT tasks or we were boosted to RT priority,
    * keep the priority unchanged. Otherwise, update priority
    * to the normal priority:
    */
    if (!rt_or_dl_prio(p->prio))
      return p->normal_prio;
    return p->prio;
  }
  ```

## 🔍 소스코드 분석2: `rt_or_dl_prio()`
- **파일 위치:** `include/linux/sched/rt.h` (Line 14~17)
- 우선순위 값을 보고 이게 RT(Real-Time)나 DL(Deadline)급인지 판별한다.
- ```MAX_RT_PRIO``` : 리눅스에서 이 값은 보통 100
- **범위의 비밀:**
  - **0 ~ 99** : 실시간(RT) 및 데드라인(DL) 프로세스 (숫자가 작을수록 고순위)
  - **100 ~ 139** : Normal 프로세스 (Nice 값에 의해 결정됨)
- 즉, ```prio < 100```이라는 건 이 프로세스가 매우 긴급하고 중요한 애라는 뜻이다.
- **핵심 코드:**
  ```c
  static inline bool rt_or_dl_prio(int prio)
  {
    return unlikely(prio < MAX_RT_PRIO);
  }
  ```

## 🔍 소스코드 분석3: `unlikely 매크로`
- **파일 위치:** `include/linux/compiler.h` (Line 77)
- ```__builtin_expect``` : 컴파일러(gcc)에게 "이 조건문은 결과가 0(False)일 확률이 매우 높아!"라고 힌트를 준다.
- 대부분의 컴퓨터에서 돌아가는 프로세스는 '일반 프로세스'지, '실시간 프로세스가 아니다.'
-  CPU는 이 힌트를 보고 **Branch Prediction** 을 최적화 한다. ```if```문 안으로 들어가지 않을 것을 예상하고 명령어를 미리 파이프라인에 채워두기 때문에, 아주 미세하지만 전체적인 실행 속도가 빨라진다.
- **핵심 코드:**
  ```c
  # define unlikely(x)	__builtin_expect(!!(x), 0)
  ```

## 🔍 직면한 문제 & 해결 (Troubleshooting)
- 딱히 읎다

## 💡 인사이트 (오늘 깨달은 것)
- **요약 :**
  - 단순히 `p->prio = normal_prio(p);`라고 하지 않는 이유는 priority inversion 방지 때문이다.

    **1. priority inheritance :** 낮은 순위의 프로세스가 중요한 자원(Lock)을 들고 있을 때, 높은 순위의 프로세스가 기다려야 한다면? 커널은 일시적으로 낮은 녀석의 prio를 RT급으로 확 끌어올려준다(Boosting).
  
    **2. 보호 로직 :** 이때 ``effective_prio``가 호출되면, ``rt_or_dl_prio``는 RT급이라고 판단한다. 그래서 ``normal_prio``로 되돌리지 않고 부스팅된 `prio`를 그대로 반환해서 작업을 빨리 끝내게 돕는다. 
## 🔗 참고 자료
- Priority Inversion State
- [Link] https://yabmoons.tistory.com/663